// Put this at the top
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // Generated by flutterfire configure
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';
import 'package:csv/csv.dart';
import 'package:share_plus/share_plus.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'dart:io';
import 'package:path_provider/path_provider.dart';

final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  await FirebaseMessaging.instance.subscribeToTopic("entry_notifications");
  await FirebaseMessaging.instance.subscribeToTopic("intruder_alerts");

  FirebaseMessaging.onMessage.listen((RemoteMessage msg) {
    final type = msg.data['type'];
    final title = msg.notification?.title ?? '';
    final body = msg.notification?.body ?? '';
    if (type == 'intruder') {
      showDialog(
        context: navigatorKey.currentContext!,
        builder: (_) => AlertDialog(
          title: Text(title, style: const TextStyle(color: Colors.red)),
          content: Text(body),
          actions: [TextButton(onPressed: () => Navigator.pop(_), child: const Text('OK'))],
        ),
      );
    } else {
      ScaffoldMessenger.of(navigatorKey.currentContext!)
          .showSnackBar(SnackBar(content: Text("$title\n$body")));
    }
  });

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'FaceAccess',
      navigatorKey: navigatorKey,
      theme: ThemeData(primarySwatch: Colors.blue),
      home: StreamBuilder(
        stream: FirebaseAuth.instance.authStateChanges(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          } else if (snapshot.hasData) {
            return const FirestoreListPage();
          } else {
            return const LoginPage();
          }
        },
      ),    );
  }
}

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final emailController = TextEditingController();
  final passwordController = TextEditingController();
  String error = '';

  Future<void> _login() async {
    try {
      await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: emailController.text.trim(),
        password: passwordController.text.trim(),
      );
    } catch (e) {
      setState(() {
        error = 'Login failed. Check your credentials.';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Login")),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            TextField(
              controller: emailController,
              decoration: const InputDecoration(labelText: 'Email'),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: passwordController,
              obscureText: true,
              decoration: const InputDecoration(labelText: 'Password'),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _login,
              child: const Text('Login'),
            ),
            const SizedBox(height: 10),
            Text(error, style: const TextStyle(color: Colors.red)),
          ],
        ),
      ),
    );
  }
}


class FirestoreListPage extends StatefulWidget {
  const FirestoreListPage({super.key});
  @override
  State<FirestoreListPage> createState() => _FirestoreListPageState();
}

class _FirestoreListPageState extends State<FirestoreListPage> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  DateTimeRange? _selectedDateRange;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _tabController.addListener(() {
      if (_tabController.indexIsChanging == false) {
        setState(() {}); // Rebuild when tab changes
      }
    });
    final today = DateTime.now();
    _selectedDateRange = DateTimeRange(
      start: DateTime(today.year, today.month, today.day),
      end: DateTime(today.year, today.month, today.day, 23, 59, 59),
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _pickDateRange() async {
    final picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2023),
      lastDate: DateTime.now(),
      initialDateRange: _selectedDateRange,
    );

    if (!mounted) return;

    if (picked != null) {
      setState(() {
        _selectedDateRange = DateTimeRange(
          start: picked.start,
          end: picked.end.add(const Duration(
              hours: 23, minutes: 59, seconds: 59, milliseconds: 999)),
        );
      });
    }
  }

    Future<void> _exportCsv() async {
    final snapshot = await FirebaseFirestore.instance.collection('access_logs').get();
    final logs = snapshot.docs.map((doc) => doc.data()).toList();

    final filteredLogs = logs.where((data) {
      final name = (data['name'] ?? '').toString().toLowerCase();
      final timestamp = data['time'] != null ? DateTime.tryParse(data['time'].toString()) : null;

      if (timestamp == null) return false;

      final inRange = _selectedDateRange == null ||
          ((timestamp.isAfter(_selectedDateRange!.start) || timestamp.isAtSameMomentAs(_selectedDateRange!.start)) &&
              (timestamp.isBefore(_selectedDateRange!.end) || timestamp.isAtSameMomentAs(_selectedDateRange!.end)));

      final matchesSearch = name.contains(_searchQuery);

      return inRange && matchesSearch;
    }).toList();

    final rows = <List<String>>[];
    rows.add(['Name', 'Time', 'Status']);

    for (var data in filteredLogs) {
      final name = data['name'] ?? 'Unknown';
      final time = data['time']?.toString() ?? '';
      final status = data['success'] == true ? 'Allowed' : 'Intruder';
      rows.add([name, time, status]);
    }

    final csv = const ListToCsvConverter().convert(rows);
    final directory = await getTemporaryDirectory();
    final path = '${directory.path}/access_logs.csv';
    final file = File(path);
    await file.writeAsString(csv);

    Share.shareXFiles([XFile(path)], text: 'Access logs CSV');
  }

  @override
  Widget build(BuildContext context) {
    final logsStream = FirebaseFirestore.instance
        .collection('access_logs')
        .orderBy('time', descending: true)
        .snapshots();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Access Logs'),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(icon: Icon(Icons.verified_user), text: 'Allowed'),
            Tab(icon: Icon(Icons.warning), text: 'Intruders'),
          ],
        ),
        actions: [
          IconButton(icon: const Icon(Icons.calendar_today), onPressed: _pickDateRange),
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () => FirebaseAuth.instance.signOut(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _exportCsv,
        child: const Icon(Icons.download),
        tooltip: 'Export both tabs as CSV',
      ),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(10),
            child: TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search by name',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: () {
                    _searchController.clear();
                    setState(() => _searchQuery = '');
                  },
                )
                    : null,
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
              ),
              onChanged: (value) => setState(() => _searchQuery = value.toLowerCase()),
            ),
          ),
          if (_selectedDateRange != null)
            Padding(
              padding: const EdgeInsets.only(bottom: 8),
              child: Text(
                'Showing from ${DateFormat('yyyy-MM-dd').format(_selectedDateRange!.start)} '
                    'to ${DateFormat('yyyy-MM-dd').format(_selectedDateRange!.end)}',
                style: const TextStyle(color: Colors.grey),
              ),
            ),
          Expanded(
            child: StreamBuilder<QuerySnapshot>(
              stream: logsStream,
              builder: (context, snapshot) {
                if (snapshot.hasError) return Center(child: Text('Error: ${snapshot.error}'));
                if (snapshot.connectionState == ConnectionState.waiting) return const Center(child: CircularProgressIndicator());

                final docs = snapshot.data!.docs;

                final filteredDocs = docs.where((doc) {
                  final data = doc.data() as Map<String, dynamic>;
                  final name = (data['name'] ?? '').toString().toLowerCase();
                  final success = data['success'] == true;
                  final timestamp = data['time'] != null ? DateTime.tryParse(data['time'].toString()) : null;
                  if (timestamp == null) return false;

                  final inRange = _selectedDateRange == null ||
                      ((timestamp.isAfter(_selectedDateRange!.start) || timestamp.isAtSameMomentAs(_selectedDateRange!.start)) &&
                          (timestamp.isBefore(_selectedDateRange!.end) || timestamp.isAtSameMomentAs(_selectedDateRange!.end)));

                  final matchesSearch = name.contains(_searchQuery);
                  final isAllowedTab = _tabController.index == 0;

                  return inRange && matchesSearch && ((isAllowedTab && success) || (!isAllowedTab && !success));
                }).toList();

                if (filteredDocs.isEmpty) return const Center(child: Text('No logs found.'));

                return ListView.builder(
                  itemCount: filteredDocs.length,
                  itemBuilder: (context, index) {
                    final data = filteredDocs[index].data() as Map<String, dynamic>;
                    final userName = data['name'] ?? 'Unknown';
                    final success = data['success'] == true;
                    final timestamp = data['time'] != null
                        ? DateTime.tryParse(data['time'].toString())
                        : DateTime.now();
                    final formattedTime = DateFormat('yyyy-MM-dd HH:mm:ss').format(timestamp!);

                    return ListTile(
                      leading: CircleAvatar(
                        backgroundImage: data['image_url'] != null ? NetworkImage(data['image_url']) : null,
                        child: data['image_url'] == null
                            ? Icon(success ? Icons.person : Icons.warning, color: success ? Colors.blue : Colors.red)
                            : null,
                      ),
                      title: Text(userName),
                      subtitle: Text(formattedTime),
                      trailing: Icon(success ? Icons.check_circle : Icons.block, color: success ? Colors.green : Colors.red),
                      onTap: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(builder: (_) => AccessLogDetailPage(data: data)),
                        );
                      },
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

class AccessLogDetailPage extends StatelessWidget {
  final Map<String, dynamic> data;
  const AccessLogDetailPage({super.key, required this.data});

  @override
  Widget build(BuildContext context) {
    final name = data['name'] ?? 'Unknown';
    final imageUrl = data['image_url'];
    final timestamp = data['time'] != null ? DateTime.tryParse(data['time'].toString()) : DateTime.now();
    final formattedTime = DateFormat('yyyy-MM-dd HH:mm:ss').format(timestamp!);

    return Scaffold(
      appBar: AppBar(title: const Text('Access Log Detail')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            imageUrl != null
                ? CircleAvatar(radius: 50, backgroundImage: NetworkImage(imageUrl))
                : const CircleAvatar(radius: 50, child: Icon(Icons.person, size: 40)),
            const SizedBox(height: 16),
            Text(name, style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text('Time: $formattedTime', style: const TextStyle(fontSize: 16)),
            const SizedBox(height: 16),
            if (data.containsKey('extra_info')) Text('More info: ${data['extra_info']}'),
          ],
        ),
      ),
    );
  }
}
